% Neural Networks Assignment 1
% By: Pepijn van Heiningen (s1045105) & Michiel Vos (???)

function task_1(filename)
    %Find, for each sample, the most likely density function that was used for generating the sample and the most likely value of the parameter s.
    load(filename);
    counter = 1;
    results = zeros(1000,4,4); %s, function, dataset
    data = [A B C D];
    functions = {@normal, @par, @rec, @tri};
    functionname = {'normal' 'parabolic' 'rectangular' 'triangular'};
    for dataset = 1:4
        for s = 0.5:0.001:1.5
            for func = 1:4
                results(counter,func,dataset) = log_likelihood(data(:,dataset), functions{func}, s);
            end
            counter = counter + 1;
        end
        counter = 1;
    end
    [max1, j] = max(results);
    [max2, i] = max(max1(:,:,:));
    disp('Part 1:');
    disp(['Sample A is (most likely) generated by the ' functionname{i(:,:,1)} ' density function with parameter ' sprintf('%i', 0.5+0.001*j(:,i(:,:,1),1)) '.']);
    disp(['Sample B is (most likely) generated by the ' functionname{i(:,:,2)} ' density function with parameter ' sprintf('%i', 0.5+0.001*j(:,i(:,:,2),2)) '.']);
    disp(['Sample C is (most likely) generated by the ' functionname{i(:,:,3)} ' density function with parameter ' sprintf('%i', 0.5+0.001*j(:,i(:,:,3),3)) '.']);
    disp(['Sample D is (most likely) generated by the ' functionname{i(:,:,4)} ' density function with parameter ' sprintf('%i', 0.5+0.001*j(:,i(:,:,4),4)) '.']);
    
    %demonstrate (numerically or by a formal proof) that the area under the parabola (par.m) is always 1, independently on the value of s.
    fun = @(x,s) par(x,s);
    counter = 1;
    for i=0.01:0.01:100
        output(counter) = quadgk(@(x)fun(x,i),-i,i);
        counter = counter + 1;
    end
    disp('Part 2:');
    disp(['Mean: ' sprintf('%f', mean(output))])
    disp(['Std: ' sprintf('%f', std(output))])
    
    %Estimate all six parameters of the corresponding Gaussian mixture of two normal distributions (i.e., pA, pB, µA, µB, ?A, and ?B) using three different methods:
    load('mix2.mat')
    values = x;
    classification = class(:);
    counterA = 1;
    counterB = 1;
    for i=1:size(x)
        if(class(i)=='A')
            classA(counterA) = values(i);
            counterA = counterA + 1;
        else
            classB(counterB) = values(i);
            counterB = counterB + 1;
        end
    end
    disp('Part 3:');
    disp(['pA: ' sprintf('%f', size(classA')/size(classification(:))) ', pB: ' sprintf('%f', size(classB')/size(classification(:))) ', µA: ' sprintf('%f', mean(classA)) ', µB: ' sprintf('%f', mean(classB)) ', sA: ' sprintf('%f', std(classA)) ', and sB: ' sprintf('%f', std(classB))]);
end

function chance = log_likelihood(sample,distr,s)
    chance = sum(log(distr(sample,s)));
end